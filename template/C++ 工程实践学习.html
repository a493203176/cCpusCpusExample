<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600553 (zh-CN, DDL); Windows/6.2.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1773"/>

<div>
<span><div><div>不带指针的类的设计</div><div><br/></div><div>如何设计一个不带指针的c++类,构造函数,析构</div><div>通常情况下,可以不需要设计析构函数, complex为例,复数类</div><div>实部+虚部</div><div>设计类中,构造函数的重载遇到函数默认参数的时候,要防止未决情况的发生</div><div>Pass by value &amp; pass by reference </div><div>同一个class的object互为友元</div><div>1). 希望能够使用成员化初始列表进行构造初始化的设计</div><div>2). 希望数据尽量使用private</div><div>3). 传值和传引用(尽量使用传引用,效率比较高,编译器在传递过程拷贝的字节尽可能少)</div><ol><li><div>const的常量成员函数</div></li><ol><li><div>1 const设计意义</div></li></ol><li><div>构造函数与重载</div></li><li><div>类设计中的参数传递</div></li><li><div>引用作为参数和返回值的设计技巧</div></li><li><div>使用值传递而非传递的场景</div></li><li><div>使用全局函数非类函数成员函数一个操作符重载&lt;&lt;</div></li></ol><div><br/></div><div><br/></div><div><br/></div><div>面向对象的类的设计</div><div>带指针的类的设计</div><div>对象的初始化, 构造与析构, 内存的分配: 从基于对象到面向对象</div><div>class  A</div><div>A() // 默认的构造函数</div><div>A(const A&amp;) //默认的拷贝构造函数</div><div>~A()</div><div>A &amp; operator=( const A&amp; a)</div><div><br/></div><div>初始化对于对象重要意义: C++的对象是复杂数据类型,是一个一个分量(有基本数据类型构成)复合的对于业务有逻辑意义的实体,由于基本数据类型不设计到内存的分配,而复杂数据类型的构建,通常是建立在堆空间的,那么我们就需要对其进行管理</div><div>最好在设计类的时候,能够显式构造和析构函数,特别指出,如果你的class中含有pointer(指针),必须处理好构造和析构,不要使用默认的</div><div>int a; cout &lt;&lt; a;</div><div>char * pCstr = (char *)malloc(1024); cout&lt;&lt;pCstr;</div><div>我们希望所有对象在建立之后都要一个固定的默认值,这样才有利于我们处理逻辑,必须有针对性的处理你的默认构造函数</div><div><br/></div><div>new 与 delete 解读: malloc / free</div><div>在我们的设计中new是c++的语法,它在构建对象的时候,会调用构造函数</div><div>new 的底层就是malloc</div><div>正是因为我们要手工维护堆空间的管理,所以我们要对对象的构造,拷贝构造,析构要体会</div><div>new 有多个意义</div><div>new plain new , nothrow new, placement new</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>char * GetMemory(long long size)</div><div>{</div><div>       char * p = new char[size];</div><div>       return p;</div><div>}</div><div><br/></div><div>       //try {</div><div>       //     char * p = GetMemory(1024 * 1024 * 1204 * 2);</div><div>       //}</div><div>       //catch (const std::bad_alloc &amp;ex) {</div><div>       //     cout &lt;&lt; ex.what() &lt;&lt; endl;</div><div>       //}</div><div>       //char * p = new(nothrow)char[1000 * 1024 * 1024*2];</div><div>       //if (p == NULL)</div><div>       //{</div><div>       //     cout &lt;&lt; &quot;分配失败&quot; &lt;&lt; endl;</div><div>       //}</div><div>       // placement new</div><div>       char * p = new char[4];</div><div>       if (p != NULL) {</div><div>              char * q = new(p)char[1000];</div><div>       }</div><div>       else {</div><div>              cout &lt;&lt; &quot;分配失败&quot; &lt;&lt; endl;</div><div>       }</div></div><div><br/></div><div>new 在我们的使用上分成了两部再走:</div><div>第一步再底层利用malloc进行动态的堆内存分配</div><div>第二步在已经构建好的内存上,用placement new 在做构造函数的调用</div><div><br/></div><div>第4讲: 类间关系的设计继承,组合与多态 =&gt; 设计模式</div><div><br/></div><div><br/></div><div><br/></div><div>本讲: C++的语法糖</div><div>别名:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using namespace std;</div><div>namespace space {</div><div>       template&lt;class T &gt;  using ptr = T* ;</div><div>}</div><div>int add(int a, int b)</div><div>{</div><div>       return a + b;</div><div>}</div><div>typedef int(*ADD)(int a, int b);</div><div>using FUNC = int(*)(int a, int b);</div><div>using co = std::ios_base::fmtflags;    // 简写数据类型</div><div>int main(void)</div><div>{</div><div>       ADD pAdd = add;</div><div>       cout &lt;&lt; pAdd(1, 2) &lt;&lt; endl;</div><div>       FUNC func = add;</div><div>       cout &lt;&lt; func(3, 4) &lt;&lt; endl;</div><div>       space::ptr&lt;int&gt;pint(new int(15));</div><div>       cout &lt;&lt; *pint &lt;&lt; &quot;,&quot; &lt;&lt; pint &lt;&lt; endl;</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><br/></div><div><br/></div><div>调试和静态断言</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>       cout &lt;&lt; __LINE__ &lt;&lt; endl;  // 哪一行</div><div>       cout &lt;&lt; __FILE__ &lt;&lt; endl; // 哪个文件</div><div>       cout &lt;&lt; __DATE__ &lt;&lt; endl; // 哪个时间</div><div>       cout &lt;&lt; __FUNCTION__ &lt;&lt; endl; // 哪个函数</div><div>       char test = 'c';</div><div>       //static_assert(sizeof(test) &gt; 1, &quot;sizeof of lower&quot;);</div><div>       //assert(sizeof(test) &lt; 0 ); // 不满足调试就断言</div></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">R与转义字符语法</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">为了兼容linux 和 window 各平台的问题,反斜杆</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#333333" face="Monaco">       string path = R&quot;(“CHar3CPlsuPlusGrammerTrick.exe”(Win32) : 已加载“C:\Windows\SysWOW64\sspicli.dll”。无法查找或打开 PDB 文件。)&quot;;</font></div><div><font color="#333333" face="Monaco">       cout &lt;&lt; path.c_str() &lt;&lt; endl;</font></div></div><div><br/></div><div>宽字符与本地化</div><div>宽字符就是为了解决西文以外的字符编码</div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">宽字符: 西文1字节,  中文两个字节</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">ASCII : IOS-8859-1</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">中文: GBK GB2312   GB18380 两个字节 (国标码)</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Big5 </span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">UTF-8: 3个字节</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">l18n</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>#include &lt;stdlib.h&gt;</div><div>#include &lt;locale&gt;</div><div>int main()</div><div>{</div><div>       setlocale(LC_ALL, &quot;chs&quot;);</div><div>       const wchar_t * p1 = L&quot;1235667abdd&quot;;</div><div>       std::wcout &lt;&lt; p1 &lt;&lt; std::endl;</div><div>       const wchar_t *  p2 = L&quot;中国11134dafa&quot;;</div><div>       std::wcout &lt;&lt; p2 &lt;&lt; std::endl;</div><div>       std::cin.get();</div><div>       return 0;</div><div>}</div></div><div><br/></div><div><br/></div><div>空指针的二义性: 应当使用nullptr初始化指针</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using namespace std;</div><div>void go(int num) {</div><div>       cout &lt;&lt; &quot;整数函数&quot; &lt;&lt; endl;</div><div>}</div><div>void go(int * pointer) {</div><div>       cout &lt;&lt; &quot;指针函数&quot; &lt;&lt; endl;</div><div>}</div><div>int main(void)</div><div>{</div><div>       int * p = NULL; // 在c++中初始化指针,请用nullptr</div><div>       go(p);</div><div>       //go(NULL); 这个在不同的平台上,它的结果不确定</div><div>       go(nullptr);</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><br/></div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">auto自动类型与typeid</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">typeid 输出类型</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using namespace std;</div><div>int main()</div><div>{</div><div>       double db = 3.14;</div><div>       double * pdb = &amp;db;</div><div>       auto num = pdb;</div><div>       cout &lt;&lt; typeid(db).name() &lt;&lt; endl;</div><div>       cout &lt;&lt; typeid(pdb).name() &lt;&lt; endl;</div><div>       cout &lt;&lt; typeid(num).name() &lt;&lt; endl;</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">auto 与内部函数绑定机制</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>#include &lt;functional&gt;</div><div>using namespace std;</div><div>using namespace std::placeholders;</div><div>// 仿函数: 创建一个函数指针,引用一个结构体或者</div><div>// 一个类的内部供应函数</div><div>// 回调函数在面向对象的一个设计</div><div>struct MyStruct</div><div>{</div><div>       void add(int a) {</div><div>              cout &lt;&lt; a &lt;&lt; endl;</div><div>       }</div><div>       void add2(int a, int b) {</div><div>              cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</div><div>       }</div><div>       void add3(int a, int b, int c)</div><div>       {</div><div>              cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</div><div>       }</div><div>};</div><div>int main(void)</div><div>{</div><div>       MyStruct s;</div><div>       auto func = bind(&amp;MyStruct::add, &amp;s, _1);</div><div>       auto func2 = bind(&amp;MyStruct::add2, &amp;s, _1, _2);</div><div>       auto func3 = bind(&amp;MyStruct::add3, &amp;s, _1, _2, _3);</div><div>       func(10);</div><div>       func2(10, 20);</div><div>       func3(10, 20, 30);</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">const 与 mutable</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using namespace std;</div><div>class  Test</div><div>{</div><div>public:</div><div>       mutable int x; // 不受成员函数const限制</div><div>       void func() const {</div><div>              x += 1;</div><div>              cout &lt;&lt; x &lt;&lt; endl;</div><div>       }</div><div>};</div><div>int main(void)</div><div>{</div><div>       Test c;</div><div>       c.x = 0;</div><div>       c.func();</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">staic_cast , reinterpret_cast 之c++类型转换</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>       int * p = static_cast&lt;int *&gt;(malloc(100));</div><div>       </div><div>       int number = 99;</div><div>       //</div><div>       char * p = reinterpret_cast&lt;char *&gt;(&amp;number);</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">non explict 的构造函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>class FClass</div><div>{</div><div>public:</div><div>       explicit FClass(double _data) : data(_data) {</div><div>       }</div><div>       operator double() {</div><div>              return data;</div><div>       }</div><div>private:</div><div>       double data;</div><div>};</div><div>int main()</div><div>{</div><div>       FClass f(1);</div><div>       int a = 4 + f;//  此处的f是一种non explicit的使用</div><div>       std::cout &lt;&lt; a &lt;&lt; std::endl;</div><div>       //FClass f2 = f + 4;</div><div>       std::cin.get();</div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">_cpluscplus 编译发的标准: 从vs到QT</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl; // 输出c++标准</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">一切皆为对象 --  std::function 可调用对象包装器</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">可调用的对象包装器</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">可以统一的方式来处理函数</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">c++借鉴了java中基于对象的回调: 闭包</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">将函数封装成对象</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">一切皆为对象,我可以把一个动作封装成一个对象</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">轮胎,方向盘 ==&gt; 汽车</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">把组装的过程也可以看成一个对象: 用一个类builder类</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">std::function</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>#include &lt;functional&gt;</div><div>using namespace std;</div><div>void func()</div><div>{</div><div>       cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</div><div>}</div><div>class FClass</div><div>{</div><div>public:</div><div>       static int foo_func(int a) {</div><div>              cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl;</div><div>              return a;</div><div>       }</div><div>};</div><div>class AClass {</div><div>public :</div><div>       int operator()(int a) {</div><div>              cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; a &lt;&lt; endl;</div><div>              return a;</div><div>       }</div><div>};</div><div>// std::function: 可以取代函数指针,实现将将对象可以向函数一样调用</div><div>int main(void)</div><div>{</div><div>       function&lt;void(void)&gt; fr1 = func;</div><div>       fr1();</div><div>       function&lt;int(int)&gt;fr2 = FClass::foo_func;</div><div>       fr2(1);</div><div>       AClass aObj;</div><div>       fr2 = aObj;</div><div>       fr2(100);</div><div>       cin.get();</div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">lambda表达式的工程意义与延时加载细节: 函数体的自由定义</span></div><div><span style="font-size: 9pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using namespace std;</div><div>int main()</div><div>{</div><div>       // 函数式编程</div><div>       //</div><div>       auto funA = [](int a) {</div><div>              a *= 2;</div><div>              cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;</div><div>       };</div><div>       funA(2);</div><div>       // lambda表达式的延时调用</div><div>       // auto funB = [=] {} 调用时不会影响本身变量的值</div><div>       int a = 0;</div><div>       auto funB = [=] {</div><div>              return a;</div><div>       };</div><div>       a += 1;</div><div>       cout &lt;&lt; funB() &lt;&lt; endl;</div><div>       // auto funC = [&amp;b] {} 使用引用</div><div>       int b = 0;</div><div>       auto funC = [&amp;b] {</div><div>              return b;</div><div>       };</div><div>       b += 1;</div><div>       cout &lt;&lt; funC() &lt;&lt; endl;</div><div>       // 作用域加载</div><div>       int c = 0;</div><div>       auto f1 = [=]()mutable {</div><div>              c++;</div><div>              return c;</div><div>       };</div><div>       cout &lt;&lt; f1() &lt;&lt; endl;</div><div>       cin.get();</div><div>       </div><div>       return 0;</div><div>}</div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">new _FILE _LINE综合案例: 简易内存检测类的设计</span></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><img src="C++ 工程实践学习_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">对象构建时间性能构建中的开销</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#333333" face="Monaco">// 如何只能我的程序运行起来的空间/时间</font></div><div><font color="#333333" face="Monaco">// 对象的时间性能我们可以通过clock函数进行自动检测</font></div><div><font color="#333333" face="Monaco">#include &lt;iostream&gt;</font></div><div><font color="#333333" face="Monaco">#include &lt;ctime&gt;</font></div><div><font color="#333333" face="Monaco">using namespace std;</font></div><div><font color="#333333" face="Monaco">class Val</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">public:</font></div><div><font color="#333333" face="Monaco">       Val(double v = 1.0) {</font></div><div><font color="#333333" face="Monaco">              for (int i = 0; i &lt; 10000; i++) {</font></div><div><font color="#333333" face="Monaco">                     d[i] = v + i;</font></div><div><font color="#333333" face="Monaco">              }</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">       void Init(double v = 1.0) {</font></div><div><font color="#333333" face="Monaco">              for (int i = 0; i &lt; 10000; i++) {</font></div><div><font color="#333333" face="Monaco">                     d[i] = v + i;</font></div><div><font color="#333333" face="Monaco">              }</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">private:</font></div><div><font color="#333333" face="Monaco">       double d[10000];</font></div><div><font color="#333333" face="Monaco">};</font></div><div><font color="#333333" face="Monaco">class Object</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">public:</font></div><div><font color="#333333" face="Monaco">       // 这个构建方式要比下面那个快1倍</font></div><div><font color="#333333" face="Monaco">       Object(double a = 1.0):v(a) {};</font></div><div><font color="#333333" face="Monaco">       //Object(double a = 1.0) {</font></div><div><font color="#333333" face="Monaco">       //     v.Init(a);</font></div><div><font color="#333333" face="Monaco">       //}</font></div><div><font color="#333333" face="Monaco">private:</font></div><div><font color="#333333" face="Monaco">       Val v;</font></div><div><font color="#333333" face="Monaco">};</font></div><div><font color="#333333" face="Monaco">int main()</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">       clock_t startTime = clock();</font></div><div><font color="#333333" face="Monaco">       for (int i = 0; i &lt; 10000; i++) {</font></div><div><font color="#333333" face="Monaco">              Object o(5.0);</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">       clock_t endTime = clock() - startTime;</font></div><div><font color="#333333" face="Monaco">       cout &lt;&lt; endTime &lt;&lt; endl;</font></div><div><font color="#333333" face="Monaco">       cin.get();</font></div><div><font color="#333333" face="Monaco">       return 0;</font></div><div><font color="#333333" face="Monaco">}</font></div></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">临时对象的构建: 对象构建空间性能构建中的开销问题</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">Qt 与 vs2017 编译器现象还不一样 </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#333333" face="Monaco">#include &lt;iostream&gt;</font></div><div><font color="#333333" face="Monaco">using namespace std;</font></div><div><font color="#333333" face="Monaco">class Matrix</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">public:</font></div><div><font color="#333333" face="Monaco">       Matrix(double d = 1.0) {</font></div><div><font color="#333333" face="Monaco">              cout &lt;&lt; &quot;Matrix::Matrix()&quot; &lt;&lt; endl;</font></div><div><font color="#333333" face="Monaco">              for (int i=0;i&lt;10;i++)</font></div><div><font color="#333333" face="Monaco">                     for (int j = 0; j &lt; 10; j++) {</font></div><div><font color="#333333" face="Monaco">                           m[i][j] = d;</font></div><div><font color="#333333" face="Monaco">                     }</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">       Matrix(Matrix &amp;mt) {</font></div><div><font color="#333333" face="Monaco">              cout &lt;&lt; &quot;Matrix::Matrix(Matrix &amp;mt)&quot; &lt;&lt; endl;</font></div><div><font color="#333333" face="Monaco">              memcpy(this, &amp;mt, sizeof(Matrix));</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">       Matrix&amp; operator=(const Matrix&amp; mt) {</font></div><div><font color="#333333" face="Monaco">              cout &lt;&lt; &quot;Matrix::Matrix&amp; operator=(Matrix&amp; mt)&quot; &lt;&lt; endl;</font></div><div><font color="#333333" face="Monaco">              if (this == &amp;mt) {</font></div><div><font color="#333333" face="Monaco">                     return *this;</font></div><div><font color="#333333" face="Monaco">              }</font></div><div><font color="#333333" face="Monaco">              memcpy(this, &amp;mt, sizeof(Matrix));</font></div><div><font color="#333333" face="Monaco">              return *this;</font></div><div><font color="#333333" face="Monaco">       }</font></div><div><font color="#333333" face="Monaco">       friend const Matrix operator+(const Matrix &amp;arg1, const Matrix &amp;arg2);</font></div><div><font color="#333333" face="Monaco">private:</font></div><div><font color="#333333" face="Monaco">       double m[10][10];</font></div><div><font color="#333333" face="Monaco">};</font></div><div><font color="#333333" face="Monaco">const Matrix operator+(const Matrix &amp;arg1, const Matrix &amp;arg2)</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">       // 临时对象也会调用构造函数</font></div><div><font color="#333333" face="Monaco">       Matrix sum;</font></div><div><font color="#333333" face="Monaco">       for (int i = 0; i&lt;10; i++)</font></div><div><font color="#333333" face="Monaco">              for (int j = 0; j &lt; 10; j++) {</font></div><div><font color="#333333" face="Monaco">                     sum.m[i][j] = arg1.m[i][j] + arg2.m[i][j];</font></div><div><font color="#333333" face="Monaco">              }</font></div><div><font color="#333333" face="Monaco">       return sum;</font></div><div><font color="#333333" face="Monaco">}</font></div><div><font color="#333333" face="Monaco">int main(void)</font></div><div><font color="#333333" face="Monaco">{</font></div><div><font color="#333333" face="Monaco">       Matrix a(2.0), b(3.0), c;</font></div><div><font color="#333333" face="Monaco">       c = a + b;</font></div><div><font color="#333333" face="Monaco">       cin.get();</font></div><div><font color="#333333" face="Monaco">       return 0;</font></div><div><font color="#333333" face="Monaco">}</font></div></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><img src="C++ 工程实践学习_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">可变参数模板实例: Singleton的改写</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">没看懂 </span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">templete 模板 还不懂</span></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">c++11的内存泄露: sharePtr 与 WeakPtr</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">内存泄露</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">share_ptr:使用的是引用计数,每一个</span><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">shared_ptr</span><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">都指向相同的内存</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">只有在最后一个shared_ptr析构的时候,才会释放内存</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">不建议,直接用shared_ptr作为函数参数进行传递,尤其复杂类型</span></div><div><span style="font-size: 12px;"><br/></span></div><div><span style="font-size: 12px;"><br/></span></div><div><font style="font-size: 12pt;"><b>alighotf字节对齐</b></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>#include &lt;iostream&gt;</div><div>using std::cout;</div><div>using std::endl;</div><div>struct <font color="#FF0000">alignas(16)</font> TestStruct</div><div>{</div><div>       char a;</div><div>       int b;</div><div>};</div><div>int main(void)</div><div>{</div><div>       cout &lt;&lt; &quot;sizeof(char)&quot; &lt;&lt; sizeof(char) &lt;&lt; endl;</div><div>       cout &lt;&lt; &quot;sizeof(int)&quot; &lt;&lt; sizeof(int) &lt;&lt; endl;</div><div>       cout &lt;&lt; &quot;sizeof(TestStruct)&quot; &lt;&lt; sizeof(TestStruct) &lt;&lt; endl;</div><div>       </div><div>       cout &lt;&lt; &quot;offset char a: &quot; &lt;&lt; offsetof(TestStruct,a) &lt;&lt; endl;</div><div>       cout &lt;&lt; &quot;offset char b: &quot; &lt;&lt; offsetof(TestStruct, b) &lt;&lt; endl;</div><div>       cout &lt;&lt; &quot;alignof(TestStruct)&quot; &lt;&lt; alignof(TestStruct) &lt;&lt; endl;</div><div>       std::cin.get();</div><div>       return 0;</div><div>}</div></div><div><br/></div><div><font style="font-size: 12pt;"><b>基于chrono库替代boost的timer:  函数效率执行的测算</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><br/></div></span>
</div></body></html> 